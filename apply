#!/bin/sh
# yes the shell
# 2010-08-31 Kacper Wysocki <comotion@krutt.org> Initial version
#
# bottom up is better than top down

# the two keys I use for signing gone manifests
#  add your own key here
# 107B264D # comotion@krutt.org
# CE49888C # kwy@redpill-linpro.com

. ./target

doscript() {
   script=$1
   shift
   echo " [INFO] Execing module/$script"
   if [ -d "modules/$script" ]; then
      modules/$script/module $@
   else
      modules/$script $@
   fi;
}

foreach() {
   cmd=$1
   shift;
   for call in $@
   do
      $cmd $call $spec
   done
}

usage () {
   echo "git clone repo/gone ; cd gone; ./apply"
   echo
   echo "./apply nocheck - do not check file integrity"
   echo "./apply check   - only check integrity"
   echo "./apply quiet   - only print important stuff"
}

# hostname, $fqdn or other specifics are kept in branches
git checkout $host 2>/dev/null
git checkout $fqdn 2>/dev/null

git branch
# potential weakness: one machine may have many roles, not in this scheme though
# edit: keep separate branch for each role...
# or keep the same files and figure out a way to do multiple inheritance
# .. bah, do special things in the modules
#

#### some important functions ... the real red meat  ####

# do integrity check of all available methods.
# normally you're only using one method, the safest one you can afford
# contrived to allow you to decide which one(s) when generating the manifest(s)
# just by signing the manifests you want to use.
# someone might have snuck in a file that is missing in the manifest, so only use
# the manifest when applying files.

#
# XXX:
# Do we want to do this the hard way? This needs more than just a manifest:
# there is a multiuser use case for signing some files with a different key.
PASSED=
integrity_check () {
   for arg in $@
   do
      if [ "$arg" = "quiet" ]
         then
         quiet='--quiet'
      fi
   done

   if [ -z "`which gpg`" ]
   then
      echo "gpg not available, can't guarantee integrity"
      exit 4
   fi
   for key in $GPG_KEYS
      do
      gpg --recv-key $key
   done

   for method in $check_methods
   do
      file=$check_filename.$method
      if [ -f $file.gpg ]
      then
         # no sense checking if we're missing programs
         if [ -z "`which $method`" ]
         then
            echo $method not available
            continue
         fi

         # a
         [ -f $file ] && mv $file $file.old
         gpg --yes --output $file -d $file.gpg || exit 7
         diff $file.old $file

         # ah the shittiness of bash exit codes
         if $method $quiet -c $file
         then
            # only need to check strongest method available
            # cryptographically useless to check weaker methods once we pass
            PASSED="$method"
            break
         else
            echo "Integrity check $method failed!"
            exit 2
         fi
      fi
   done
   if [ -z "$PASSED" ]
   then
      echo "Integrity not available."
      exit 3
   fi
}

match_copy() {
# substitute installed copies for version controlled ones
   srcdir=$1
   shift
   check_methods=`shift`
   workdir=$PWD
   if [ -z "$check_methods" ]
   then
      # no signature, no manifest
      FILES="`find "$srcdir/files" -type f | sort`"
   else
      # close a loophole by using files from the manifest only
      FILES=`cat manifest.$PASSED | cut -f 1 -d ' ' --complement | grep '^ \./files/' | sed 's/^ .\/files\///'`
      [ $! ] && exit 2 # quit on error
   fi
   #â™¯ why the hello not rsync?: b/c diff!
   # files should be relative paths
   for file in $FILES
   do
      target=`echo $file | sed 's/.*\/files\//\//'`
      if [ ! -f $target ]
         then
         if [ -d `dirname $target` ]
         then
            echo " [INFO] install target ($file -> $target)"
            cp -a $file $target
         else
            echo "not installing $file, no target dir"
         fi
         continue
      fi
      # XXX: remember attribs, uid/gid, extattr and selinux context
      # any and all uniquely definable characteristics of the file
      # problem: bash sux for this :-(
      #stati=`stat -t $file` # terse pickle
      statd=`stat -c '%a %u %g %C' $file 2>/dev/null`
      #stato=`stat -t $target` # terse target
      stats=`stat -c '%a %u %g %C' $target 2>/dev/null`
      #stata=( $stats ) # an array. arrays suck in dash
      attrs=`lsattr "$target" | awk '{print $1}'`
      # compare the pickle with the target
      if [ "$stats" != "$statd" ]
         then
         # noncritical failure
         echo ' [WARN] pickle and target do not match, check lsattr and ownership'
         #echo ${stata[0]} ${stata[1]} ${stata[2]} # not portable to dash
      fi
      # diff is what's important
      if ! diff -bud $target $file || [ $? = 2 ]
      then
         if [ -z "$USER_CHOSE" ]
         then
            echo "$target $stats $attrs"
            echo " $file.$statd"
            echo "[] $target"
            echo "$file doesn't match local copy, (a)pply, (commit) or [SKIP]?"
            read choose
         else
            choose=$USER_CHOSE
         fi
         case $choose in
            [aA])
            echo " [INFO] overriding target ($file -> $target)"
            cp -a $file $target
            ;;

            commit)
            echo " [INFO] commiting target ($target -> $file)"
            cp -a $target $file
            git diff $file
            git add $file
            git commit
            ;;

            *)
               # skip
         esac
      fi
   done
   cd $workdir
}

if [ "$1" = "help" ]
then
   usage
fi

# off or on by default?
# if [ "$1" = "check" ]
if [ "$1" != "nocheck" ] # on by default
then
   integrity_check $@
else
   check_methods=
fi

if [ "$1" = "check" ]
then
   # just check
   exit
fi

# execute module script and place files where they should be
dosync()  {
   doscript $1
   match_copy modules/$1 $check_methods
}

# kick the script - basically what chef, slaughter and puppet does
# execute all the modules and then sync any file non-module files
foreach dosync $MODULES
match_copy . $check_methods
