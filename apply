#!/bin/sh
# yes the shell
# 2010-08-31 Kacper Wysocki <comotion@krutt.org> Initial version
# 
# bottom up is better than top down

# the two keys I use for signing gone manifests
#  add your own key here
# 107B264D # comotion@krutt.org
# CE49888C # kwy@redpill-linpro.com

GPG_KEYS="107B264D CE49888C"

usage () {
   echo "git clone repo/gone ; cd gone; ./apply"
   echo
   echo "./apply nocheck - do not check file integrity"
   echo "./apply check   - only check integrity"
   echo "./apply quiet   - only print important stuff"
}

# let defaults be default: fall back to logic
fqdn=`hostname -f`
host=`hostname`

# comment the methods out to disable integrity checking
check_methods='sha512sum sha384sum sha256sum sha1sum md5sum'
check_filename=manifest

# hostname, $fqdn or other specifics are kept in branches
git checkout $host 2>/dev/null
git checkout $fqdn 2>/dev/null

git branch
# potential weakness: one machine may have many roles, not in this scheme though
# edit: keep separate branch for each role...
# or keep the same files and figure out a way to do multiple inheritance
# .. bah, do special things in the modules
#

#### some important functions ... the real red meat  ####

# do integrity check of all available methods.
# normally you're only using one method, the safest one you can afford
# contrived to allow you to decide which one(s) when generating the manifest(s)
# just by signing the manifests you want to use.
# someone might have snuck in a file that is missing in the manifest, so only use
# the manifest when applying files.

# 
# XXX:
# Do we want to do this the hard way? This needs more than just a manifest:
# there is a multiuser use case for signing some files with a different key.
PASSED=
integrity_check () {
   for arg in $@
   do
      if [ "$arg" = "quiet" ]
         then
         quiet='--quiet'
      fi
   done

   if [ -z "`which gpg`" ]
   then
      echo "gpg not available, can't guarantee integrity"
      exit 4
   fi
   for key in $GPG_KEYS
      do
      gpg --recv-key $key
   done

   for method in $check_methods
   do
      file=$check_filename.$method
      if [ -f $file.gpg ]
      then
         # no sense checking if we're missing programs
         if [ -z "`which $method`" ]
         then
            echo $method not available
            continue
         fi
         
         # a
         [ -f $file ] && mv $file $file.old
         gpg --yes --output $file -d $file.gpg || exit 7
         diff $file.old $file
            
         # ah the shittiness of bash exit codes
         if $method $quiet -c $file
         then
            # only need to check strongest method available
            # cryptographically useless to check weaker methods once we pass
            PASSED="$method"
            break
         else
            echo "Integrity check $method failed!"
            exit 2
         fi
      fi
   done
   if [ -z "$PASSED" ]
   then
      echo "Integrity not available."
      exit 3
   fi
}

match_copy () {
# substitute installed copies for version controlled ones
   check_methods=`shift`
   workdir=$PWD
   if [ -z "$check_methods" ]
   then
      # no signature, no manifest
      FILES="`find . -type f -wholename '*/files/*' | sort`"
   else
      # close a loophole by using files from the manifest only
      FILES=`cat manifest.$PASSED | cut -f 1 -d ' ' --complement | grep '^ \./files/' | sed 's/^ .\/files\///'`
      [ $! ] && exit 2 # quit on error
   fi
   #â™¯ why the hello not rsync?: b/c diff!
   # files should be relative paths
   for file in $FILES
   do
      target=`echo $file | sed 's/.*\/files\//\//'`
      if [ ! -f $target ]
         then
         if [ -d `dirname $target` ]
            then
            cp -av $file $target
         else
            echo "not installing $file, no target dir"
         fi
         continue
      fi
      # XXX: remember attribs, uid/gid, extattr and selinux context
      # any and all uniquely definable characteristics of the file
      # problem: bash sux for this :-(
      #stati=`stat -t $file` # terse pickle
      statd=`stat -c '%a %u %g %C' $file 2>/dev/null`
      #stato=`stat -t /$file` # terse target
      stats=`stat -c '%a %u %g %C' /$file 2>/dev/null`
      #stata=( $stats ) # an array. arrays suck in dash
      attrs=`lsattr "/$file" | awk '{print $1}'`
      # compare the pickle with the target
      echo "$target $stats $attrs"
      echo " $file.$statd"
      if [ "$stats" != "$statd" ]
         then
         # noncritical failure
         echo 'pickle and target do not match, check lsattr and ownership'
         #echo ${stata[0]} ${stata[1]} ${stata[2]} # not portable to dash
      fi
      # diff is what's important
      if ! diff -bud $target $file || [ $? = 2 ]
      then
         if [ -z "$USER_CHOSE" ]
            then
            echo "$file doesn't match local copy, (a)pply, (commit) or [SKIP]?"
            read choose
         else
            choose=$USER_CHOSE
         fi
         case $choose in
            [aA])
            cp -av $file $target
            ;;

            commit)
            cp -av $target $file
            git diff $file
            git add $file
            git commit
            ;;

            *)
               # skip
         esac
      fi
   done
   cd $workdir
}
if [ "$1" = "help" ]
then
   usage
fi

# off or on by default?
# if [ "$1" = "check" ]
if [ "$1" != "nocheck" ] # on by default
then
   integrity_check $@
else
   check_methods=
fi
if [ "$1" = "check" ]
then
   # just check
   exit
fi
# place files where they should be
match_copy $check_methods

# kick the script - basically what chef, slaughter and puppet does
. $workdir/defaults
# dash doesn't like it when we source relative scripts :-(

