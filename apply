#!/bin/sh
# yes the shell
# 2010-08-31 Kacper Wysocki <comotion@krutt.org> Initial version
# 
# bottom up is better than top down
# 
# git clone repo/gone ; cd gone; ./apply

# let defaults be default: fall back to logic
fqdn=`hostname -f`
host=`hostname`

# comment the methods out to disable integrity checking
check_methods='sha512sum sha384sum sha256sum sha1sum md5sum'
check_filename=manifest

# hostname, $fqdn or other specifics are kept in branches
git checkout $host 2>/dev/null
git checkout $fqdn 2>/dev/null

git branch
# XXX weakness: one machine may have many roles, not in this scheme though
# edit: keep separate repos for each role...
# or keep the same files and figure out a way to do multiple inheritance

#### some important functions ... the real red meat  ####

# do integrity check of all available methods.
# normally you're only using one method, the safest one you can afford
# contrived to allow you to decide which one(s) when generating the manifest(s)
# just by signing the manifests you want to use.
# someone might have snuck in a file that is missing in the manifest, so only use
# the manifest when applying files.

# 
# XXX:
# Do we want to do this the hard way? This needs more than just a manifest:
# there is a multiuser use case for signing some files with a different key.
PASSED=
integrity_check () {
   if [ -z "`which gpg`" ]
   then
      echo "gpg not available, can't guarantee integrity"
      exit 4
   fi
   for method in $check_methods
   do
      file=$check_filename.$method
      if [ -f $file.gpg ]
      then
         # no sense checking if we're missing programs
         if [ -z "`which $method`" ]
         then
            echo $method not available
            continue
         fi
         
         # a
         [ -f $file ] && mv $file $file.old
         gpg --yes --output $file -d $file.gpg || exit 7
         diff $file.old $file
            
         # ah the shittiness of bash exit codes
         if $method -c $file #| grep -v ': OK$'
         then
            # only need to check strongest method available
            # cryptographically useless to check weaker methods once we pass
            PASSED="$method"
            break
         else
            echo "Integrity check $method failed!"
            exit 2
         fi
      fi
   done
   if [ -z "$PASSED" ]
   then
      echo "Integrity not available."
      exit 3
   fi
   
}
   
match_copy () {
# substitute installed copies for version controlled ones
   workdir=$PWD
   cd files/
   if [ -z check_methods ]
   then
      FILES="`find . -type f | sort | sed 's/^.\///'`"
   else
      # close a loophole by using files from the manifest only
      FILES=`cat ../manifest.$PASSED | cut -f 1 -d ' ' --complement | grep '^ \./files/' | sed 's/^ .\/files\///'`
      [ $! ] && exit 2
   fi
   #â™¯ why the hello not rsync?: b/c diff!
   # files should be relative paths
   for file in $FILES
   do
      echo $file
      stat /$file # XXX: should diff/do permissions too
      # oh and selinux context shizzat... but that mabbe a module
      if ! diff -bud /$file $file || [ $? = 2 ]
      then
         if [ -z "$USER_CHOSE" ]
            then
            echo "$file doesn't match local copy, (a)pply, (commit) or [SKIP]?"
            read choose
         else
            choose=$USER_CHOSE
         fi
         case $choose in
            [aA])
            cp -av $file /$file
            ;;

            commit)
            cp -av /$file $file
            git diff $file
            git add $file
            git commit
            ;;
            
            *)
               # skip
         esac
      fi
   done
   cd $workdir
}

# off or on by default?
# if [ "$1" = "check" ]
if [ "$1" != "nocheck" ]
then
   integrity_check
fi

# place files where they should be
match_copy

# kick the script - basically what chef, slaughter and puppet does
. $workdir/defaults
# dash doesn't like it when we source relative scripts :-(

